<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webpack Bundle Analysis</title>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <!-- HTMX removed, using vanilla JS -->
    <style>
      /* General Styles */
      body { padding-top: 0 !important; }
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
      ::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
      ::-webkit-scrollbar-thumb:hover { background: #555; }
      /* Simple styling for error/warning details */
      .problem-details { font-size: 0.8em; color: #4a5568; margin-left: 1em; }

      /* Modal Styles */
      .modal-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex; align-items: center; justify-content: center;
        z-index: 1000; /* Ensure it's on top */
        opacity: 0; visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }
      .modal-overlay.active { opacity: 1; visibility: visible; }
      .modal-content {
        background-color: white;
        padding: 2rem;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        max-width: 90%;
        width: 60rem; /* Adjust as needed */
        max-height: 80vh;
        overflow-y: auto;
        position: relative; /* For close button positioning */
      }
      .modal-close-btn {
        position: absolute;
        top: 0.5rem; right: 0.75rem;
        background: none; border: none;
        font-size: 1.5rem; line-height: 1;
        cursor: pointer; color: #6b7280; /* gray-500 */
      }
      .modal-close-btn:hover { color: #1f2937; /* gray-800 */ }
      .clickable-asset { cursor: pointer; text-decoration: underline; color: #2563eb; /* blue-600 */ }
      .clickable-asset:hover { color: #1d4ed8; /* blue-800 */ }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto bg-white p-6 rounded-lg shadow-md my-8">
        <h1 class="text-2xl font-bold mb-4 text-gray-800">Webpack Bundle Analysis</h1>
        <p class="text-sm text-gray-600 mb-2">Generated: <span id="generation-time">Loading...</span></p>
        <p class="text-sm text-gray-600 mb-4">Stats file: <span id="stats-file-path">Loading...</span></p>

        <!-- Filter Controls -->
        <div class="mb-4 p-4 bg-gray-50 border border-gray-200 rounded flex flex-wrap gap-4 items-center">
             <div class="flex items-center">
                 <label for="minSizeKb" class="text-sm text-gray-700 mr-2">Hide assets <</label>
                 <input type="number" id="minSizeKb" name="minSizeKb" value="1" min="0" step="0.1"
                        class="w-20 px-2 py-1 text-sm border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 mr-1" />
                 <span class="text-sm text-gray-700">KB</span>
            </div>
            <div class="flex-grow min-w-[200px]">
                 <label for="excludePatterns" class="sr-only">Exclude patterns (comma-separated or /regex/)</label>
                 <input type="text" id="excludePatterns" name="excludePatterns" value=""
                        placeholder="Exclude patterns (e.g., node_modules/, .map$)"
                        class="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                        title="Comma-separated list of strings or /regex/ patterns to exclude" />
            </div>
            <span id="loading-indicator-table" class="ml-2 text-sm text-gray-500" style="display: none;">Loading...</span>
        </div>

        <!-- Errors container -->
        <div id="errors-container" class="mb-4"></div>
        <!-- Warnings container -->
        <div id="warnings-container" class="mb-4"></div>

        <h2 class="text-xl font-semibold mb-3 text-gray-700">Asset Sizes</h2>
        <div class="overflow-auto relative max-h-[70vh] border border-gray-200 rounded">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="sticky top-0 z-10 bg-gray-50">
                    <tr>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Asset Name</th>
                        <th scope="col" class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Size</th>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Visualization</th>
                    </tr>
                </thead>
                <tbody id="asset-table-body" class="bg-white divide-y divide-gray-200">
                    <!-- Content loaded -->
                    <tr><td colspan="3" class="p-4 text-center text-gray-500">Loading assets...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Module Details Modal -->
    <div id="module-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close-btn" aria-label="Close modal">&times;</button>
            <h3 id="modal-title" class="text-xl font-semibold mb-4 text-gray-800">Modules for Asset</h3>
            <div id="modal-body" class="text-sm">
                <p>Loading module details...</p>
                <!-- Module list will be rendered here -->
            </div>
        </div>
    </div>

    <!-- __INITIAL_DATA_PLACEHOLDER__ -->
    <script>
        // --- Utility Functions ---
        function formatBytes(bytes, decimals = 2) {
            if (!Number.isFinite(bytes) || bytes < 0) return 'N/A';
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.max(0, Math.min(Math.floor(Math.log(bytes) / Math.log(k)), sizes.length - 1));
            return `${Number.parseFloat((bytes / (k ** i)).toFixed(dm))} ${sizes[i]}`;
        }

        // --- Global State ---
        let fullStatsData = null; // Holds the entire stats object in export mode
        let allAssets = []; // Holds the asset list (fetched or from embedded)
        let configData = {}; // Holds config data (stats path, warnings, errors)
        let isExportMode = false; // Flag to check mode

        // --- Page Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            isExportMode = typeof window.__INITIAL_DATA__ !== 'undefined';
            console.log(`Running in ${isExportMode ? 'Export' : 'Serve'} mode.`);

            // --- Elements ---
            const generationTimeEl = document.getElementById('generation-time');
            const statsPathEl = document.getElementById('stats-file-path');
            const minSizeKbInput = document.getElementById('minSizeKb');
            const excludePatternsInput = document.getElementById('excludePatterns');
            const tableBody = document.getElementById('asset-table-body');
            const warningsContainer = document.getElementById('warnings-container');
            const errorsContainer = document.getElementById('errors-container');
            const loadingIndicator = document.getElementById('loading-indicator-table');
            const moduleModal = document.getElementById('module-modal');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');

            // --- Initial Setup ---
            // generationTimeEl updated in initializeApp

            // --- LocalStorage Persistence ---
            const savedMinSizeKb = localStorage.getItem('minSizeKb') || '1';
            const savedExcludePatterns = localStorage.getItem('excludePatterns') || '';
            if (minSizeKbInput) minSizeKbInput.value = savedMinSizeKb;
            if (excludePatternsInput) excludePatternsInput.value = savedExcludePatterns;

            function saveState() {
                if (minSizeKbInput) localStorage.setItem('minSizeKb', minSizeKbInput.value);
                if (excludePatternsInput) localStorage.setItem('excludePatterns', excludePatternsInput.value);
            }

            // --- Filtering Logic ---
            function getFilterValues() {
                const minSizeKb = parseFloat(minSizeKbInput?.value || '0');
                const excludePatternsRaw = excludePatternsInput?.value || '';
                const excludeFilters = excludePatternsRaw.split(',')
                    .map(p => p.trim())
                    .filter(p => p)
                    .map(p => {
                        if (p.startsWith('/') && p.endsWith('/')) {
                            try { return new RegExp(p.slice(1, -1)); } catch (e) { console.warn('Invalid regex:', p); return null; }
                        }
                        return p;
                    })
                    .filter(p => p !== null);
                return {
                    minSizeBytes: (isNaN(minSizeKb) ? 0 : minSizeKb) * 1024,
                    excludeFilters
                };
            }

            function filterAssets(assetsToFilter, filters) {
                // Ensure assetsToFilter is an array before filtering
                if (!Array.isArray(assetsToFilter)) {
                    console.error("filterAssets received non-array:", assetsToFilter);
                    return [];
                }
                return assetsToFilter.filter(asset => {
                    // Basic check: Ensure asset is an object and has a name property
                    if (typeof asset !== 'object' || asset === null || typeof asset.name !== 'string') {
                        console.warn("Filtering out invalid asset object:", asset);
                        return false; // Filter out assets without a valid name
                    }

                    const size = asset.size ?? 0;
                    const name = asset.name; // Now we know name is a string
                    let hidden = false;

                    if (size < filters.minSizeBytes) {
                        hidden = true;
                    }

                    if (!hidden && filters.excludeFilters.length > 0) {
                        for (const filter of filters.excludeFilters) {
                            if (filter instanceof RegExp) {
                                if (filter.test(name)) { hidden = true; break; }
                            } else if (typeof filter === 'string') {
                                if (name.includes(filter)) { hidden = true; break; }
                            }
                        }
                    }
                    return !hidden;
                });
            }

            // --- Table Rendering ---
            function renderTable(assets) {
                if (!tableBody) return;
                tableBody.innerHTML = ''; // Clear previous

                if (!Array.isArray(assets)) {
                    console.error("renderTable received non-array:", assets);
                    tableBody.innerHTML = '<tr><td colspan="3" class="px-6 py-4 text-center text-red-600">Error: Invalid data format for table.</td></tr>';
                    return;
                }

                if (assets.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="3" class="px-6 py-4 text-center text-gray-500">No assets match filters.</td></tr>';
                    return;
                }

                const maxSize = Math.max(0, ...assets.map(a => a.size ?? 0));
                let tableHtml = '';
                assets.forEach(asset => {
                    const sizeBytes = asset.size ?? 0;
                    const formattedSize = formatBytes(sizeBytes);
                    const percentage = maxSize > 0 ? Math.max(0, Math.min(100, (sizeBytes / maxSize) * 100)).toFixed(1) : 0;
                    // Make asset name clickable
                    tableHtml += `
                        <tr data-asset-name="${asset.name}">
                            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900 break-all">
                                <a href="#" class="clickable-asset" data-asset-name="${asset.name}">${asset.name}</a>
                            </td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-right">${formattedSize}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700" title="${percentage}% of largest asset (${formattedSize})">
                                  <div class="bg-blue-600 h-2.5 rounded-full" style="width: ${percentage}%"></div>
                                </div>
                            </td>
                        </tr>
                    `;
                });
                tableBody.innerHTML = tableHtml;
            }

             // --- Display Problems (Warnings/Errors) ---
             function displayProblems(container, problems, title, titleColor, textColor, listId) {
                 if (container && Array.isArray(problems) && problems.length > 0) {
                     // Use <details> and <summary> for native collapsible behavior
                     let html = `
                        <details class="border border-gray-200 rounded mb-2 bg-gray-50/50" open="false">
                            <summary class="cursor-pointer p-2 ${titleColor} font-semibold text-base flex justify-between items-center">
                                <span>${title}: (${problems.length})</span>
                                <span class="text-xs font-normal text-gray-500">(Click to expand)</span>
                            </summary>
                            <div class="p-2 border-t border-gray-200">
                                <ul id="${listId}" class="list-disc list-inside text-sm ${textColor} space-y-1 max-h-48 overflow-y-auto">`; // Added max-h-48 and overflow-y-auto

                     problems.forEach(p => {
                         html += `<li>${p.message || 'Unknown problem'}`;
                         // Add details if available
                         let details = [];
                         if (p.moduleName) details.push(`Module: ${p.moduleName}`);
                         if (p.loc) details.push(`Location: ${p.loc}`);
                         // Show more details, maybe wrap in pre/code for stack traces? For now, keep it simple.
                         if (p.details) details.push(`Details: ${p.details.substring(0, 150)}...`);
                         if (p.stack) details.push(`Stack: ${p.stack.substring(0, 150)}...`); // Add stack trace snippet

                         if (details.length > 0) {
                             // Use pre for better formatting of details/stack if needed, but simple div for now
                             html += `<div class="problem-details pl-4 text-xs">${details.join('<br>')}</div>`;
                         }
                         html += `</li>`;
                     });
                     html += `
                                </ul>
                            </div>
                        </details>`;
                     container.innerHTML = html;

                     // Add event listener to save state (optional, but good UX)
                     const detailsElement = container.querySelector('details');
                     if (detailsElement) {
                         detailsElement.addEventListener('toggle', () => {
                             localStorage.setItem(`${listId}-open`, detailsElement.open);
                         });
                         // Restore state
                         const isOpen = localStorage.getItem(`${listId}-open`) === 'true';
                         detailsElement.open = isOpen;
                     }

                 } else if (container) {
                     container.innerHTML = ''; // Clear if no problems
                 }
             }

             function displayWarnings(warnings) {
                 // Pass a unique ID for the list
                 displayProblems(warningsContainer, warnings, 'Warnings', 'text-orange-700', 'text-orange-600', 'warnings-list');
             }

             function displayErrors(errors) {
                  // Pass a unique ID for the list
                 displayProblems(errorsContainer, errors, 'Errors', 'text-red-700', 'text-red-600', 'errors-list');
             }

            // --- Update View (Filter and Render) ---
            function updateView() {
                const filters = getFilterValues();
                const filtered = filterAssets(allAssets || [], filters);
                renderTable(filtered);
                saveState();
            }

            // --- Modal Logic ---
            function openModal() {
                if (moduleModal) moduleModal.classList.add('active');
            }
            function closeModal() {
                if (moduleModal) moduleModal.classList.remove('active');
            }

            function getModulesForAssetClientSide(assetName) {
                if (!fullStatsData || !Array.isArray(fullStatsData.assets)) return [];

                const asset = fullStatsData.assets.find(a => a.name === assetName);
                if (!asset || !Array.isArray(fullStatsData.chunks)) return [];

                const relevantChunkIds = new Set(asset.chunks);
                const relevantModules = new Set(); // Use Set to avoid duplicates

                // Check modules within relevant chunks
                if (Array.isArray(fullStatsData.chunks)) {
                    fullStatsData.chunks.forEach(chunk => {
                        if (relevantChunkIds.has(chunk.id) && Array.isArray(chunk.modules)) {
                            chunk.modules.forEach(module => relevantModules.add(module));
                        }
                    });
                }

                // Check top-level modules as fallback or primary source
                if (relevantModules.size === 0 && Array.isArray(fullStatsData.modules)) {
                     fullStatsData.modules.forEach(module => {
                         if (Array.isArray(module.chunks) && module.chunks.some(chunkId => relevantChunkIds.has(chunkId))) {
                             relevantModules.add(module);
                         }
                     });
                 }

                // Convert Set to array and sort
                return Array.from(relevantModules).sort((a, b) => (b.size ?? 0) - (a.size ?? 0));
            }


            async function showModuleDetails(assetName) {
                if (!modalTitle || !modalBody) return;

                modalTitle.textContent = `Modules for: ${assetName}`;
                modalBody.innerHTML = '<p class="text-gray-500">Loading...</p>';
                openModal();

                let modules = [];
                let errorMsg = null;

                try {
                    if (isExportMode) {
                        modules = getModulesForAssetClientSide(assetName);
                    } else {
                        // Fetch from API in serve mode
                        const response = await fetch(`/api/asset-details/${encodeURIComponent(assetName)}`);
                        if (!response.ok) {
                            throw new Error(`Failed to fetch details: ${response.status} ${response.statusText}`);
                        }
                        modules = await response.json();
                    }
                } catch (error) {
                    console.error(`Error getting module details for ${assetName}:`, error);
                    errorMsg = error instanceof Error ? error.message : String(error);
                }

                // Render module list or error
                if (errorMsg) {
                     modalBody.innerHTML = `<p class="text-red-600">Error loading modules: ${errorMsg}</p>`;
                } else if (modules && modules.length > 0) {
                    let modulesHtml = '<ul class="list-disc list-inside space-y-2 max-h-[60vh] overflow-y-auto">';
                    modules.forEach(mod => {
                        const formattedSize = formatBytes(mod.size ?? 0);
                        // Simple display: Name (Size)
                        // Could add more details like issuer later
                        modulesHtml += `
                            <li title="${mod.identifier || mod.name}">
                                <span class="font-medium text-gray-800">${mod.name || 'Unknown Module'}</span>
                                <span class="text-gray-600">(${formattedSize})</span>
                                ${mod.issuerName ? `<br><span class="text-xs text-gray-500 pl-4">imported by: ${mod.issuerName}</span>` : ''}
                            </li>`;
                    });
                    modulesHtml += '</ul>';
                    modalBody.innerHTML = modulesHtml;
                } else {
                    modalBody.innerHTML = '<p class="text-gray-500">No module details found for this asset.</p>';
                }
            }

            // --- Initialization Logic ---
            function initializeApp(loadedConfig, loadedAssets) {
                configData = loadedConfig || {};
                allAssets = loadedAssets || []; // Store the asset list

                // Update static info like generation time and stats path
                if (generationTimeEl) {
                    generationTimeEl.textContent = configData.generationTime
                        ? new Date(configData.generationTime).toLocaleString()
                        : new Date().toLocaleString(); // Fallback for serve mode
                }
                if (statsPathEl) statsPathEl.textContent = configData.statsFilePath || (isExportMode ? 'N/A (Embedded)' : 'Loading...');

                // Display warnings and errors
                displayWarnings(configData.warnings || []);
                displayErrors(configData.errors || []);

                // Add event listeners AFTER elements are potentially rendered
                if (minSizeKbInput) minSizeKbInput.addEventListener('input', updateView);
                if (excludePatternsInput) excludePatternsInput.addEventListener('input', updateView);

                // Event listener for modal close button
                if (modalCloseBtn) modalCloseBtn.addEventListener('click', closeModal);
                // Close modal if clicking outside the content area
                if (moduleModal) {
                    moduleModal.addEventListener('click', (event) => {
                        if (event.target === moduleModal) { // Check if click is on the overlay itself
                            closeModal();
                        }
                    });
                }

                // Event delegation for clicking asset names in the table
                if (tableBody) {
                    tableBody.addEventListener('click', (event) => {
                        const target = event.target;
                        // Check if the clicked element is a clickable asset link
                        if (target.tagName === 'A' && target.classList.contains('clickable-asset')) {
                            event.preventDefault(); // Prevent default link behavior
                            const assetName = target.dataset.assetName;
                            if (assetName) {
                                showModuleDetails(assetName);
                            }
                        }
                    });
                }

                // Initial render of the table
                updateView();
            }

            // --- Mode-Specific Loading ---
            if (isExportMode) {
                // Data is embedded in window.__INITIAL_DATA__
                fullStatsData = window.__INITIAL_DATA__ || {}; // Store the full embedded data
                initializeApp(fullStatsData, fullStatsData.assets);
            } else {
                // Serve mode: Fetch config, then assets
                if (loadingIndicator) loadingIndicator.style.display = 'inline';
                let fetchedConfig = {};

                fetch('/api/config')
                    .then(response => response.ok ? response.json() : Promise.reject(`Config fetch failed: ${response.status}`))
                    .then(config => {
                        fetchedConfig = config; // Store fetched config
                        // Update path immediately
                        if (statsPathEl) statsPathEl.textContent = config.statsFilePath || 'Error loading path';
                        // Fetch assets now
                        return fetch('/api/table');
                    })
                    .then(response => response.ok ? response.json() : Promise.reject(`Table fetch failed: ${response.status}`))
                    .then(assets => {
                        if (assets.error) { // Check for explicit error property from backend
                            return Promise.reject(`API Error: ${assets.error}`);
                        }
                        // Combine fetched config and assets for initialization
                        initializeApp(fetchedConfig, assets);
                    })
                    .catch(error => {
                        console.error('Error fetching data in serve mode:', error);
                        if (tableBody) tableBody.innerHTML = `<tr><td colspan="3" class="px-6 py-4 text-center text-red-600">Error loading data: ${error}. Check console.</td></tr>`;
                        if (statsPathEl) statsPathEl.textContent = 'Error loading path';
                        // Initialize with empty/error state
                        initializeApp({ statsFilePath: 'Error loading path', warnings: [], errors: [{ message: `Failed to load data: ${error}` }] }, []);
                    })
                    .finally(() => {
                         if (loadingIndicator) loadingIndicator.style.display = 'none';
                    });
            }
        }); // End DOMContentLoaded
    </script>
</body>
</html>
