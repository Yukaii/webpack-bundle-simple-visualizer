<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webpack Bundle Analysis (Vue)</title>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <!-- Include Vue.js -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <style>
      /* General Styles */
      body { padding-top: 0 !important; }
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
      ::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
      ::-webkit-scrollbar-thumb:hover { background: #555; }
      /* Simple styling for error/warning details */
      .problem-details { font-size: 0.8em; color: #4a5568; margin-left: 1em; }

      /* Modal Styles */
      .modal-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex; align-items: center; justify-content: center;
        z-index: 1000; /* Ensure it's on top */
        opacity: 0; visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }
      .modal-overlay.active { opacity: 1; visibility: visible; }
      .modal-content {
        background-color: white;
        padding: 2rem;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        max-width: 90%;
        width: 60rem; /* Adjust as needed */
        max-height: 80vh;
        overflow-y: auto;
        position: relative; /* For close button positioning */
      }
      .modal-close-btn {
        position: absolute;
        top: 0.5rem; right: 0.75rem;
        background: none; border: none;
        font-size: 1.5rem; line-height: 1;
        cursor: pointer; color: #6b7280; /* gray-500 */
      }
      .modal-close-btn:hover { color: #1f2937; /* gray-800 */ }
      .clickable-asset { cursor: pointer; text-decoration: underline; color: #2563eb; /* blue-600 */ }
      .clickable-asset:hover { color: #1d4ed8; /* blue-800 */ }

      /* Style for Vue loading state */
      [v-cloak] { display: none; }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <!-- Vue App Root -->
    <div id="app" v-cloak class="container mx-auto bg-white p-6 rounded-lg shadow-md my-8">
        <h1 class="text-2xl font-bold mb-4 text-gray-800">Webpack Bundle Analysis (Vue)</h1>
        <p class="text-sm text-gray-600 mb-2">Generated: <span >{{ formattedGenerationTime }}</span></p>
        <p class="text-sm text-gray-600 mb-4">Stats file: <span >{{ statsFilePathDisplay }}</span></p>

        <!-- Filter Controls -->
        <div class="mb-4 p-4 bg-gray-50 border border-gray-200 rounded flex flex-wrap gap-4 items-center">
             <div class="flex items-center">
                 <label for="minSizeKb" class="text-sm text-gray-700 mr-2">Hide assets <</label>
                 <input type="number" id="minSizeKb" name="minSizeKb" v-model.number="minSizeKb" min="0" step="0.1"
                        class="w-20 px-2 py-1 text-sm border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 mr-1" />
                 <span class="text-sm text-gray-700">KB</span>
            </div>
            <div class="flex-grow min-w-[200px]">
                 <label for="excludePatterns" class="sr-only">Exclude patterns (comma-separated or /regex/)</label>
                 <input type="text" id="excludePatterns" name="excludePatterns" v-model.lazy="excludePatternsRaw"
                        placeholder="Exclude patterns (e.g., node_modules/, .map$)"
                        class="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                        title="Comma-separated list of strings or /regex/ patterns to exclude" />
            </div>
            <span v-if="isLoading" class="ml-2 text-sm text-gray-500">Loading...</span>
        </div>

        <!-- Errors container -->
        <div v-if="configData.errors && configData.errors.length > 0" class="mb-4">
             <details class="border border-gray-200 rounded mb-2 bg-gray-50/50" :open="errorsOpen">
                 <summary @click.prevent="errorsOpen = !errorsOpen" class="cursor-pointer p-2 text-red-700 font-semibold text-base flex justify-between items-center">
                     <span>Errors: ({{ configData.errors.length }})</span>
                     <span class="text-xs font-normal text-gray-500">(Click to expand)</span>
                 </summary>
                 <div class="p-2 border-t border-gray-200">
                     <ul class="list-disc list-inside text-sm text-red-600 space-y-1 max-h-48 overflow-y-auto">
                         <li v-for="(error, index) in configData.errors" :key="'error-' + index">
                             {{ error.message || 'Unknown error' }}
                             <div v-if="error.moduleName || error.loc || error.details || error.stack" class="problem-details pl-4 text-xs">
                                 <template v-if="error.moduleName">Module: {{ error.moduleName }}<br></template>
                                 <template v-if="error.loc">Location: {{ error.loc }}<br></template>
                                 <template v-if="error.details">Details: {{ truncateText(error.details, 150) }}<br></template>
                                 <template v-if="error.stack">Stack: {{ truncateText(error.stack, 150) }}</template>
                             </div>
                         </li>
                     </ul>
                 </div>
             </details>
        </div>
        <!-- Warnings container -->
        <div v-if="configData.warnings && configData.warnings.length > 0" class="mb-4">
             <details class="border border-gray-200 rounded mb-2 bg-gray-50/50" :open="warningsOpen">
                 <summary @click.prevent="warningsOpen = !warningsOpen" class="cursor-pointer p-2 text-orange-700 font-semibold text-base flex justify-between items-center">
                     <span>Warnings: ({{ configData.warnings.length }})</span>
                     <span class="text-xs font-normal text-gray-500">(Click to expand)</span>
                 </summary>
                 <div class="p-2 border-t border-gray-200">
                     <ul class="list-disc list-inside text-sm text-orange-600 space-y-1 max-h-48 overflow-y-auto">
                         <li v-for="(warning, index) in configData.warnings" :key="'warning-' + index">
                             {{ warning.message || 'Unknown warning' }}
                             <div v-if="warning.moduleName || warning.loc || warning.details || warning.stack" class="problem-details pl-4 text-xs">
                                 <template v-if="warning.moduleName">Module: {{ warning.moduleName }}<br></template>
                                 <template v-if="warning.loc">Location: {{ warning.loc }}<br></template>
                                 <template v-if="warning.details">Details: {{ truncateText(warning.details, 150) }}<br></template>
                                 <template v-if="warning.stack">Stack: {{ truncateText(warning.stack, 150) }}</template>
                             </div>
                         </li>
                     </ul>
                 </div>
             </details>
        </div>

        <h2 class="text-xl font-semibold mb-3 text-gray-700">Asset Sizes</h2>
        <div class="overflow-auto relative max-h-[70vh] border border-gray-200 rounded">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="sticky top-0 z-10 bg-gray-50">
                    <tr>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Asset Name</th>
                        <th scope="col" class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Size</th>
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Visualization</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
                    <tr v-if="isLoading && filteredAssets.length === 0">
                        <td colspan="3" class="p-4 text-center text-gray-500">Loading assets...</td>
                    </tr>
                    <tr v-else-if="!isLoading && filteredAssets.length === 0">
                        <td colspan="3" class="px-6 py-4 text-center text-gray-500">No assets match filters.</td>
                    </tr>
                    <tr v-else v-for="asset in filteredAssets" :key="asset.name" :data-asset-name="asset.name">
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900 break-all">
                            <a href="#" @click.prevent="showModuleDetails(asset.name)" class="clickable-asset">{{ asset.name }}</a>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-right">{{ formatBytes(asset.size) }}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700" :title="`${assetSizePercentage(asset)}% of largest asset (${formatBytes(asset.size)})`">
                              <div class="bg-blue-600 h-2.5 rounded-full" :style="{ width: assetSizePercentage(asset) + '%' }"></div>
                            </div>
                        </td>
                    </tr>
                     <tr v-if="fetchError">
                         <td colspan="3" class="px-6 py-4 text-center text-red-600">Error loading data: {{ fetchError }}. Check console.</td>
                     </tr>
                </tbody>
            </table>
        </div>

        <!-- Module Details Modal -->
        <div :class="['modal-overlay', { 'active': isModalVisible }]" @click.self="closeModal">
            <div class="modal-content">
                <button @click="closeModal" class="modal-close-btn" aria-label="Close modal">&times;</button>
                <h3 class="text-xl font-semibold mb-2 text-gray-800">Modules for: {{ selectedAsset?.name }}</h3>
                <!-- Filter Input for Modal -->
                <div class="mb-3">
                    <label for="modalFilter" class="sr-only">Filter modules</label>
                    <input type="text" id="modalFilter" v-model="modalFilterText" placeholder="Filter modules by name..."
                           class="w-full px-3 py-1.5 text-sm border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div class="text-sm">
                    <p v-if="isModalLoading" class="text-gray-500">Loading...</p>
                    <p v-else-if="modalError" class="text-red-600">Error loading modules: {{ modalError }}</p>
                    <div v-else-if="filteredModules && filteredModules.length > 0"> <!-- Use filteredModules -->
                        <!-- Remove list-disc, keep other styles -->
                        <ul class="list-none space-y-2 max-h-[55vh] overflow-y-auto overflow-x-hidden px-2"> <!-- Adjusted max-h, list-none -->
                            <!-- Use filteredModules -->
                            <template v-for="(mod, index) in filteredModules" :key="mod.identifier || mod.name || index">
                                <!-- Pass maxModuleSizeInModal -->
                                <module-item
                                            :module="mod"
                                            :level="0"
                                            :format-bytes="formatBytes"
                                            :module-size-percentage="moduleSizePercentage"
                                            :max-module-size-in-asset="maxModuleSizeInModal" />
                            </template>
                        </ul>
                    </div>
                    <!-- Adjust message for filtering -->
                    <p v-else-if="selectedAssetModules && selectedAssetModules.length > 0 && filteredModules.length === 0" class="text-gray-500">No modules match the filter.</p>
                    <p v-else class="text-gray-500">No module details found for this asset.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, watch, defineComponent } = Vue;

        // Define component outside createApp for global usage
        const ModuleItem = defineComponent({
            name: 'ModuleItem', // Name for recursive reference
            template: `
              <li :title="module.identifier || module.name"
                  class="mb-2 pb-2 border-b border-gray-100 last:border-b-0"
                  :style="{ marginLeft: level * 1.5 + 'rem' }">
                <div class="flex justify-between items-start mb-1"> <!-- Use items-start -->
                    <!-- Toggle Button -->
                    <button @click="toggleExpand"
                            :disabled="!hasPotentialChildren"
                            class="mr-1 text-sm w-5 h-5 flex items-center justify-center flex-shrink-0"
                            :class="{ 'cursor-pointer text-blue-600 hover:text-blue-800': hasPotentialChildren, 'text-gray-300 cursor-default': !hasPotentialChildren }"
                            :aria-expanded="isExpanded.toString()"
                            :aria-label="isExpanded ? 'Collapse dependencies' : 'Expand dependencies'">
                        <!-- Use v-if/else for clarity -->
                        <span v-if="isLoadingChildren" class="animate-spin text-xs">⏳</span>
                        <span v-else-if="hasPotentialChildren">{{ isExpanded ? '▼' : '▶' }}</span>
                        <span v-else>&nbsp;</span> <!-- Placeholder for alignment -->
                    </button>
                    <div class="min-w-0 flex-1 mr-2">
                        <span class="font-medium text-gray-800 block truncate">{{ module.name || 'Unknown Module' }}</span>
                        <span class="text-gray-600"> ({{ formatBytes(module.size) }})</span>
                    </div>
                    <!-- Show issuer only for top level -->
                    <div v-if="module.issuerName && level === 0" class="text-xs text-gray-500 text-right flex-shrink-0 ml-2">
                      imported by: {{ module.issuerName }}
                    </div>
                </div>
                <!-- Visualization Bar - Indented -->
                <div class="w-full bg-gray-200 rounded-full h-1.5 dark:bg-gray-700 ml-6"
                     :title="\`\${moduleSizePercentage(module, maxModuleSizeInAsset)}% of largest module in this asset (\${formatBytes(module.size)})\`">
                  <div class="bg-purple-600 h-1.5 rounded-full" :style="{ width: moduleSizePercentage(module, maxModuleSizeInAsset) + '%' }"></div>
                </div>
                <!-- Recursive Children -->
                <ul v-if="isExpanded && children.length > 0" class="list-none mt-2">
                    <module-item v-for="child in children"
                                 :key="child.identifier || child.name"
                                 :module="child"
                                 :level="level + 1"
                                 :format-bytes="formatBytes"
                                 :module-size-percentage="moduleSizePercentage"
                                 :max-module-size-in-asset="maxModuleSizeInAsset" />
                </ul>
                <p v-if="isExpanded && !isLoadingChildren && children.length === 0 && hasPotentialChildren" class="text-xs text-gray-400 ml-6 mt-1">No direct dependencies found.</p>
                <p v-if="errorLoadingChildren" class="text-xs text-red-500 ml-6 mt-1">Error loading dependencies: {{ errorLoadingChildren }}</p>
              </li>
            `,
            props: {
                module: { type: Object, required: true },
                level: { type: Number, default: 0 },
                formatBytes: { type: Function, required: true },
                moduleSizePercentage: { type: Function, required: true },
                maxModuleSizeInAsset: { type: Number, required: true } // Max size in the *top-level* asset
            },
            setup(props) {
                const isExpanded = ref(false);
                const isLoadingChildren = ref(false);
                const children = ref([]);
                const errorLoadingChildren = ref(null);

                // Determine if the module *might* have children based on its structure
                // For simplicity, we'll assume any module could have dependencies fetched via API.
                // A more accurate check might look at `module.reasons` if available and detailed.
                const hasPotentialChildren = computed(() => true); // Assume possible children

                const toggleExpand = async () => {
                    if (!hasPotentialChildren.value) return;

                    isExpanded.value = !isExpanded.value;

                    // Fetch children only when expanding for the first time
                    if (isExpanded.value && children.value.length === 0 && !isLoadingChildren.value && !errorLoadingChildren.value) {
                        isLoadingChildren.value = true;
                        errorLoadingChildren.value = null;
                        try {
                            // Prefer module.id if available, otherwise use identifier
                            const idToFetch = props.module.id ?? props.module.identifier;
                            if (!idToFetch) {
                                throw new Error("Module has no ID or Identifier to fetch dependencies.");
                            }
                            const response = await fetch(`/api/module-dependencies/${encodeURIComponent(idToFetch)}`);
                            if (!response.ok) {
                                throw new Error(`API Error: ${response.status} ${response.statusText}`);
                            }
                            const fetchedChildren = await response.json();
                            children.value = fetchedChildren;
                        } catch (err) {
                            console.error("Error fetching module dependencies:", err);
                            errorLoadingChildren.value = err instanceof Error ? err.message : String(err);
                            // Keep expanded to show the error
                        } finally {
                            isLoadingChildren.value = false;
                        }
                    }
                };

                return {
                    isExpanded,
                    isLoadingChildren,
                    children,
                    errorLoadingChildren,
                    hasPotentialChildren,
                    toggleExpand
                };
            }
        });

        createApp({
            components: {
                'module-item': ModuleItem // Register with kebab-case name
            },
            setup() {
                const fullStatsData = ref(null); // Holds the entire stats object in export mode
                const allAssets = ref([]); // Holds the asset list (fetched or from embedded)
                const configData = reactive({ // Holds config data (stats path, warnings, errors, time)
                    generationTime: null,
                    statsFilePath: null,
                    warnings: [],
                    errors: []
                });
                // Removed isExportMode ref
                const isLoading = ref(false);
                const fetchError = ref(null); // For initial data load errors

                // Filters
                const minSizeKb = ref(parseFloat(localStorage.getItem('minSizeKb') || '1'));
                const excludePatternsRaw = ref(localStorage.getItem('excludePatterns') || '');

                // Modal State
                const isModalVisible = ref(false);
                const isModalLoading = ref(false);
                const modalError = ref(null);
                const selectedAsset = ref(null); // Store the whole asset object
                const selectedAssetModules = ref([]);
                const maxModuleSizeInModal = ref(0); // Add state for max module size in modal
                const modalFilterText = ref(''); // Add state for modal filter input

                // Collapsible section state
                const errorsOpen = ref(localStorage.getItem('errors-list-open') === 'true');
                const warningsOpen = ref(localStorage.getItem('warnings-list-open') === 'true');

                // --- Computed Properties ---
                const formattedGenerationTime = computed(() => {
                    // Simplified: Always show current time if not loaded from config
                    return configData.generationTime
                        ? new Date(configData.generationTime).toLocaleString()
                        : new Date().toLocaleString();
                });

                const statsFilePathDisplay = computed(() => {
                    // Simplified: Show loading/error or the path
                    return configData.statsFilePath || (isLoading.value ? 'Loading...' : 'Error loading path');
                });

                const minSizeBytes = computed(() => (isNaN(minSizeKb.value) ? 0 : minSizeKb.value) * 1024);

                const excludeFilters = computed(() => {
                    return excludePatternsRaw.value.split(',')
                        .map(p => p.trim())
                        .filter(p => p)
                        .map(p => {
                            if (p.startsWith('/') && p.endsWith('/')) {
                                try { return new RegExp(p.slice(1, -1)); }
                                catch (e) { console.warn('Invalid regex:', p); return null; }
                            }
                            return p;
                        })
                        .filter(p => p !== null);
                });

                const filteredAssets = computed(() => {
                    if (!Array.isArray(allAssets.value)) return [];

                    const filters = {
                        minSizeBytes: minSizeBytes.value,
                        excludeFilters: excludeFilters.value
                    };

                    return allAssets.value.filter(asset => {
                        if (typeof asset !== 'object' || asset === null || typeof asset.name !== 'string') {
                            console.warn("Filtering out invalid asset object:", asset);
                            return false;
                        }
                        const size = asset.size ?? 0;
                        const name = asset.name;
                        let hidden = false;

                        if (size < filters.minSizeBytes) hidden = true;

                        if (!hidden && filters.excludeFilters.length > 0) {
                            for (const filter of filters.excludeFilters) {
                                if (filter instanceof RegExp) {
                                    if (filter.test(name)) { hidden = true; break; }
                                } else if (typeof filter === 'string') {
                                    if (name.includes(filter)) { hidden = true; break; }
                                }
                            }
                        }
                        return !hidden;
                    });
                });

                const maxAssetSize = computed(() => {
                     // Use filteredAssets to calculate max size based on what's visible
                     if (!filteredAssets.value || filteredAssets.value.length === 0) return 0;
                      return Math.max(0, ...filteredAssets.value.map(a => a.size ?? 0));
                 });

                 const filteredModules = computed(() => {
                     if (!Array.isArray(selectedAssetModules.value)) return [];
                     const filter = modalFilterText.value.toLowerCase().trim();
                     if (!filter) return selectedAssetModules.value; // No filter applied

                     // Recursive filtering function
                     const filterRecursive = (modules) => {
                         return modules.map(mod => {
                             const name = mod.name || '';
                             const issuerName = mod.issuerName || '';
                             const nameMatch = name.toLowerCase().includes(filter);
                             const issuerMatch = issuerName.toLowerCase().includes(filter);

                             // Recursively filter children if they exist (or might exist)
                             // Note: This assumes children are fetched/available.
                             // A simpler approach is to filter only the top level.
                             // Let's stick to filtering only the top level for now.
                             // const filteredChildren = mod.children ? filterRecursive(mod.children) : [];

                             // Keep the module if it matches or has matching children
                             // if (nameMatch || issuerMatch || filteredChildren.length > 0) {
                             //    return { ...mod, children: filteredChildren };
                             // }
                             if (nameMatch || issuerMatch) {
                                 return mod; // Keep the module if it matches
                             }
                             return null; // Discard if no match
                         }).filter(mod => mod !== null);
                     };

                     // Apply filtering only to the top-level modules fetched for the asset
                     return selectedAssetModules.value.filter(mod => {
                         const name = mod.name || '';
                         const issuerName = mod.issuerName || '';
                         return name.toLowerCase().includes(filter) || issuerName.toLowerCase().includes(filter);
                     });
                 });

                 // --- Methods ---
                 function formatBytes(bytes, decimals = 2) {
                    if (!Number.isFinite(bytes) || bytes < 0) return 'N/A';
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const dm = decimals < 0 ? 0 : decimals;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.max(0, Math.min(Math.floor(Math.log(bytes) / Math.log(k)), sizes.length - 1));
                    return `${Number.parseFloat((bytes / (k ** i)).toFixed(dm))} ${sizes[i]}`;
                }

                 function truncateText(text, maxLength) {
                     if (!text) return '';
                     return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
                 }

                function assetSizePercentage(asset) {
                    const sizeBytes = asset.size ?? 0;
                    const max = maxAssetSize.value;
                    if (max <= 0 || sizeBytes <= 0) return 0;
                    return Math.max(0, Math.min(100, (sizeBytes / max) * 100)).toFixed(1);
                }

                // --- Updated method for module percentage ---
                // Now accepts the max size for the context (asset or parent module)
                function moduleSizePercentage(module, maxContextSize) {
                    const sizeBytes = module.size ?? 0;
                    const max = maxContextSize; // Use the passed max size
                    if (max <= 0 || sizeBytes <= 0) return 0;
                    // Ensure percentage is relative to the *overall* max for the asset for consistency
                    // We use maxModuleSizeInModal which holds the max size of the top-level modules for the asset
                    const overallMax = maxModuleSizeInModal.value;
                    if (overallMax <= 0) return 0; // Avoid division by zero if modal max is 0
                    return Math.max(0, Math.min(100, (sizeBytes / overallMax) * 100)).toFixed(1);
                }
                // --- End updated method ---


                async function showModuleDetails(assetName) {
                    selectedAsset.value = allAssets.value.find(a => a.name === assetName) || { name: assetName }; // Find the full asset object
                    isModalVisible.value = true;
                    isModalLoading.value = true;
                    modalError.value = null;
                    selectedAssetModules.value = [];
                    modalFilterText.value = ''; // Clear filter when opening modal

                    try {
                        // Always fetch from API now
                        const response = await fetch(`/api/asset-details/${encodeURIComponent(assetName)}`);
                        if (!response.ok) {
                            throw new Error(`Failed to fetch details: ${response.status} ${response.statusText}`);
                        }
                        const modules = await response.json();
                        selectedAssetModules.value = modules; // Assign fetched modules
                        // Calculate max size for the newly fetched modules (top level)
                        maxModuleSizeInModal.value = Math.max(0, ...(modules.map(m => m.size ?? 0)));
                    } catch (error) {
                        console.error(`Error getting module details for ${assetName}:`, error);
                        modalError.value = error instanceof Error ? error.message : String(error);
                    } finally {
                        isModalLoading.value = false;
                    }
                }

                function closeModal() {
                    isModalVisible.value = false;
                    // Reset selected asset and modules when closing
                     selectedAsset.value = null;
                     selectedAssetModules.value = [];
                     modalError.value = null;
                     modalFilterText.value = ''; // Reset filter on close
                 }

                 function saveState() {
                    localStorage.setItem('minSizeKb', minSizeKb.value.toString());
                    localStorage.setItem('excludePatterns', excludePatternsRaw.value);
                    localStorage.setItem('errors-list-open', errorsOpen.value.toString());
                    localStorage.setItem('warnings-list-open', warningsOpen.value.toString());
                }

                // --- Watchers for Persistence ---
                watch(minSizeKb, saveState);
                watch(excludePatternsRaw, saveState);
                watch(errorsOpen, saveState);
                watch(warningsOpen, saveState);

                // --- Lifecycle Hooks ---
                onMounted(async () => {
                    // Simplified: Always run in "Serve" mode logic
                    console.log(`Running in Serve mode.`);
                    isLoading.value = true;
                    fetchError.value = null;

                    // Fetch config, then assets
                    let fetchedConfig = {};
                    try {
                        const configResponse = await fetch('/api/config');
                        if (!configResponse.ok) throw new Error(`Config fetch failed: ${configResponse.status}`);
                        fetchedConfig = await configResponse.json();
                        Object.assign(configData, fetchedConfig); // Update configData

                        const tableResponse = await fetch('/api/table');
                        if (!tableResponse.ok) throw new Error(`Table fetch failed: ${tableResponse.status}`);
                        const assets = await tableResponse.json();
                        if (assets.error) throw new Error(`API Error: ${assets.error}`);
                        allAssets.value = assets;

                    } catch (error) {
                        console.error('Error fetching data:', error);
                        fetchError.value = error.message || String(error);
                        // Update config with error state
                        Object.assign(configData, {
                            statsFilePath: 'Error loading path',
                            warnings: configData.warnings || [], // Keep existing warnings if any
                            errors: [...(configData.errors || []), { message: `Failed to load data: ${fetchError.value}` }]
                        });
                        allAssets.value = [];
                    } finally {
                        isLoading.value = false;
                    }
                });

                // --- Return values for template ---
                return {
                    configData,
                    allAssets,
                    isLoading,
                    fetchError,
                    minSizeKb,
                    excludePatternsRaw,
                    isModalVisible,
                    isModalLoading,
                    modalError,
                    selectedAsset,
                    selectedAssetModules,
                    maxModuleSizeInModal, // Pass this to template
                    errorsOpen,
                    warningsOpen,
                     // Computed
                     formattedGenerationTime,
                     statsFilePathDisplay,
                     filteredAssets,
                     filteredModules, // Add computed property
                     // Methods
                     formatBytes, // Make formatBytes available to the template context
                    truncateText,
                    assetSizePercentage,
                     showModuleDetails,
                     closeModal,
                     moduleSizePercentage, // Return the new method
                     modalFilterText, // Add ref
                     ModuleItem // Return ModuleItem so template can use it
                 };
            }
        }).mount('#app');
    </script>
</body>
</html>
